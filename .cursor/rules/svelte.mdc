---
description: Rules and best practices for Svelte 5 component development, focusing on runes, SvelteKit, TypeScript, performance, and testability, with minimal comments.
globs: ["*.svelte"]
alwaysApply: false
---
# Svelte 5 Development Standards (SvelteKit & TypeScript Focus)

<rule>
name: svelte5_best_practices
description: Core Svelte 5 development standards using runes for clarity, performance, and maintainability.
filters:
  - type: file_extension
    pattern: "\\.svelte$"
  - type: content
    pattern: "(?s).*" # Apply to all svelte file content

actions:
  - type: suggest
    message: |
      Follow these Svelte 5 development standards:

      1.  **Structure & Syntax:**
          - File Structure: `<script lang="ts">...</script>`, then `<style>...</style>` (if component-specific styles are needed beyond Tailwind), then the HTML template.
          - TypeScript: Always use `lang="ts"` in the script tag.
          - Props: Use `$props()` for accessing component props:
            ```typescript
            let { propName, optionalProp = defaultValue }: { propName: string; optionalProp?: number } = $props();
            ```
          - Two-way Bindings: Use `$bindable()` for props that need two-way binding:
            ```typescript
            let { value = $bindable() }: { value: string } = $props();
            ```
          - For complex objects or arrays, define explicit TypeScript interfaces/types in `src/lib/types/`.
          - Imports: Place all import statements at the top of the `<script>` block.

      2.  **Self-Documenting Code & Minimal Comments:**
          - No comments unless explaining *why* a complex or non-obvious piece of logic is necessary (e.g., a workaround, a specific algorithm choice).
          - Prefer clear, descriptive names for variables, functions, components, and props.
          - Logic within `<script>` tags should be broken down into small, well-named functions if it becomes complex.

      3.  **State Management (Svelte 5 Runes):**
          - **MANDATORY**: Use Svelte 5 runes for all reactivity. The `$:` syntax is FORBIDDEN in new code.
          - Local State: Use `$state()` for component-local reactive state:
            ```typescript
            let count = $state(0);
            let items = $state<Item[]>([]);
            ```
          - Derived Values: Use `$derived()` for computed values:
            ```typescript
            const doubled = $derived(count * 2);
            const filteredItems = $derived(items.filter(item => item.active));
            ```
          - Effects: Use `$effect()` for side effects and `$effect.pre()` for pre-DOM-update effects:
            ```typescript
            $effect(() => {
              console.log('Count changed:', count);
            });
            ```
          - Shared State: Utilize Svelte Stores (`writable`, `readable`, `derived`) from `src/lib/stores/` for state shared across components or routes.
            - Subscribe to stores using the `$`-prefix auto-subscription syntax (e.g., `$playerStore.isPlaying`).
          - Data Fetching: Use SvelteKit's `load` functions in `+page.ts` or `+layout.ts` (or their `.server.ts` counterparts) for loading data before a component renders.

      4.  **Rune Migration Guidelines:**
          - **FORBIDDEN**: Do not use `$:` reactive declarations in new code. All existing `$:` syntax must be migrated to runes.
          - Replace `$: variable = expression;` with `const variable = $derived(expression);` for computed values.
          - Replace `$: { statement; }` or `$: if (condition) { statement; }` with `$effect(() => { statement; });` or `$effect(() => { if (condition) { statement; } });`.
          - Use `$effect.pre()` for effects that need to run before DOM updates.
          - Convert `let` variables that are reactive to `$state()`.
          - Functions updating multiple distinct `$state` variables should be refactored into focused functions.

      5.  **Performance Considerations:**
          - Reactivity: Be mindful of reactive dependencies in `$derived` and `$effect`. Avoid unnecessary re-computations.
          - Loops: Use keyed `#each` blocks (`{#each items as item (item.id)}`) when iterating over lists where element identity is important or elements can be reordered/added/removed, to help Svelte efficiently update the DOM.
          - Conditional Rendering: Use `{#if ...}`, `{:else if ...}`, `{:else}` blocks for conditional rendering.
          - Component Composition: Break down large components into smaller, reusable ones.
          - Event Handling: Use Svelte's event directives (`on:event={handler}`). Consider event modifiers (e.g., `on:click|once`, `on:submit|preventDefault`).

      6.  **Styling (Tailwind CSS & Shadcn-Svelte):**
          - Primarily use Tailwind CSS utility classes directly in your HTML template.
          - Leverage `shadcn-svelte` components for UI, customizing them via props and Tailwind classes.
          - **Shadcn-Svelte Workflow:** Remember that `shadcn-svelte` components are typically added to your project codebase (e.g., `src/lib/components/ui`). You customize their appearance *directly* using Tailwind classes within their Svelte files. This is a core part of minimizing external custom CSS.
          - If component-specific styles are absolutely necessary and cannot be achieved with Tailwind (after considering `tailwind.config.js` extensions), use the `<style>` block. Keep such styles minimal.
          - Use `clsx` and `tailwind-merge` (available via `cn` utility from `shadcn-svelte`) for conditional or merged class names.

      7.  **Accessibility (A11y):**
          - Use semantic HTML elements (`<nav>`, `<button>`, `<article>`, etc.).
          - Provide ARIA attributes where necessary to enhance accessibility, especially for custom components or complex interactions.
          - Ensure interactive elements are keyboard accessible.
          - Include `alt` text for images.

      8.  **Testability:**
          - Design components with clear props and events to facilitate testing.
          - Business logic should ideally reside in Svelte stores, utility functions in `src/lib/utils`, or API services in `src/lib/services`, which can be tested independently.
          - Components should primarily focus on presentation and user interaction.
          - Write tests using Vitest and `@testing-library/svelte` for component rendering, interaction, and state changes.
          - Test components that use runes by verifying state changes and effect execution.

      9.  **SvelteKit Specifics:**
          - Routing: Understand and use file-based routing in `src/routes`.
          - Layouts: Utilize `+layout.svelte` for shared UI structure.
          - Endpoints: For server-side logic not directly tied to a page, use SvelteKit API routes (`+server.ts`).
          - Form Actions: Use SvelteKit's form actions for data mutations.
</rule>
