{
  "Climb": "RefX1",
  "moves": [
    {
      "status": "complete",
      "description": "Refactor `broadcast_sse_event` for Non-Blocking Operation",
      "details": "Modify `ScanTracksUseCase` to invoke `broadcast_sse_event` using `asyncio.create_task`. Additionally, refactor the internal loop of `broadcast_sse_event` in `sse_handler.py` to ensure that putting an event into one client's queue does not block sending to other clients. This involves wrapping each `q.put(event_data)` call in `asyncio.create_task`. Specific changes: 1. In `backend/src/mus/application/use_cases/scan_tracks_use_case.py`: Replace all instances of `await broadcast_sse_event(...)` with `asyncio.create_task(broadcast_sse_event(...))`. Ensure `asyncio` is imported. 2. In `backend/src/mus/infrastructure/api/sse_handler.py` (within the `broadcast_sse_event` function): Change the loop from `for q in active_sse_clients: await q.put(event_data)` to `for q in active_sse_clients: asyncio.create_task(q.put(event_data))`. Ensure `asyncio` is imported.",
      "rules_filepaths_to_follow": "`.cursor/rules/python.mdc`",
      "filepaths_to_modify": "`backend/src/mus/application/use_cases/scan_tracks_use_case.py,backend/src/mus/infrastructure/api/sse_handler.py`",
      "rest": "true"
    },
    {
      "status": "complete",
      "description": "Refactor `ScanTracksUseCase` for Batched DB Commits and Simplified SSE Strategy",
      "details": "Modify `ScanTracksUseCase.scan_directory` to process audio files in batches, with each batch's database operations committed in a separate, short-lived transaction. This aims to reduce the duration of database locks and improve API responsiveness. Remove all intermediate Server-Sent Events (SSEs) for per-track processing and per-batch progress. Implement a single, final summary SSE event to be dispatched after the entire scan operation completes. This final SSE should include `action_key: 'reload_tracks'` if any tracks were successfully added or updated during the scan, prompting clients to refresh their track lists. The summary message should be generic, e.g., 'Music library scan completed. X items processed.' The existing `tracks_added_total` can serve as the count of items successfully processed by the database for this message. No changes to `SQLiteTrackRepository.upsert_track`'s return signature are required for this simplified statistics approach. Specific changes: 1. In `backend/src/mus/application/use_cases/scan_tracks_use_case.py` (`scan_directory` and `_process_batch` methods): Restructure the database interaction to ensure `async with track_repo.session.begin():` is used for each batch of files processed, not for the entire scan. Remove all calls to `asyncio.create_task(broadcast_sse_event(...))` that send per-track or intermediate progress updates. After all batches are processed, construct one final summary payload for `broadcast_sse_event`. Set `action_key='reload_tracks'` in this final payload if `tracks_added_total > 0` (where `tracks_added_total` now represents successfully processed/changed tracks). The `ScanResponseDTO` can continue to use `tracks_added` to reflect this count, and `tracks_updated` can be set to 0.",
      "rules_filepaths_to_follow": "`.cursor/rules/python.mdc`",
      "filepaths_to_modify": "`backend/src/mus/application/use_cases/scan_tracks_use_case.py`",
      "rest": "true"
    },
    {
      "status": "todo",
      "description": "Adjust `mtime` Fallback in `_extract_metadata_sync`",
      "details": "Modify the `_extract_metadata_sync` method in `ScanTracksUseCase`. If `os.path.getmtime(file_path)` fails and raises an `OSError`, the method should log this specific error and use `0` as the `mtime` (modification time) value for the track. This prevents files with inaccessible mtime from repeatedly being processed or causing errors with timestamp comparisons in future scans. Specific changes: 1. In `backend/src/mus/application/use_cases/scan_tracks_use_case.py` (within `_extract_metadata_sync`): Locate the `except OSError:` block that currently handles `os.path.getmtime()` failure. Ensure it logs a clear warning message about the mtime retrieval failure. Set `fallback_mtime = 0` within this specific `OSError` handler for `getmtime`. If other exceptions occur during metadata extraction, the existing broader fallback to `file_path.stem` and `Unknown Artist` with `mtime` (potentially from `datetime.now()` if `os.path.getmtime` succeeded earlier or `0` if it failed) should be maintained or clarified as per this change.",
      "rules_filepaths_to_follow": "`.cursor/rules/python.mdc`",
      "filepaths_to_modify": "`backend/src/mus/application/use_cases/scan_tracks_use_case.py`",
      "rest": "skip"
    },
    {
      "status": "todo",
      "description": "Verify and Finalize with `make ci`",
      "details": "Run the `make ci` command from the project root. Ensure all linting, formatting, and tests pass without any errors or warnings. Address any reported issues to confirm the stability and correctness of the applied changes.",
      "rules_filepaths_to_follow": "`.cursor/rules/makefile.mdc,.cursor/rules/python.mdc`",
      "filepaths_to_modify": "`./`",
      "rest": "skip"
    }
  ]
}
