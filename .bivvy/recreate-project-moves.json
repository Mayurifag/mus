{
  "file_content": {
    "climb": "R3W7",
    "moves": [
      {
        "status": "complete",
        "description": "Initialize Project Structure and Root Configuration",
        "details": "Create root directories: `backend/`, `frontend/`, `docker/`. Create/update root config files: `.editorconfig`, `.gitignore` (root level), `README.md` (initial skeleton), `ARCHITECTURE.md` (initial skeleton). Initialize Git repository if not already. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "complete",
        "description": "Setup Backend Project (FastAPI, SQLModel, UV)",
        "details": "Inside `backend/`: initialize Python project with `uv`. Create `pyproject.toml` with FastAPI, SQLModel, Uvicorn, python-jose, pytest, httpx. Set up basic FastAPI app structure (`src/mus/main.py`, `src/mus/config.py`). Implement Hexagonal Architecture directory structure skeleton (`domain/entities`, `application/use_cases`, `infrastructure/api`, `infrastructure/persistence`). Define core `Track` entity using SQLModel in `backend/src/mus/domain/entities/track.py`. Setup initial SQLite database with `PlayerState` table (if storing in DB) and `Track` table. Implement `SQLiteTrackRepository` using SQLModel (async). --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "complete",
        "description": "Implement Backend Authentication (Web Access)",
        "details": "In `backend/`: Implement `GET /api/v1/auth/login-via-secret/{secret_key}` endpoint. Logic: validate key from env, generate JWT (HS256, `exp`, `iat`, `sub`) using `python-jose`, set HttpOnly cookie, redirect to `/`. JWT signing key from env. No JWT protection on other API endpoints for now (Tauri access). File `backend/src/mus/infrastructure/api/auth.py` created and `backend/src/mus/infrastructure/api/dependencies.py` for `get_current_user` (though not used on main data endpoints). --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "complete",
        "description": "Backend: Define API Data Transfer Objects (DTOs)",
        "details": "In `backend/src/mus/application/dtos/` (create if not exists) or `backend/src/mus/infrastructure/api/schemas.py` (choose one convention, PRD mentions `dtos/`), define Pydantic models for all API request and response payloads. These should include models for: `Track`, `PlayerState`, `ScanRequest`, `ScanResponse`, etc., as outlined in PRD section 3.5 'API Endpoints'. Ensure all fields, types, and optionality match the PRD. These models will be used by FastAPI for validation and serialization. Reference PRD section 3.6 for `Track` and `PlayerState` model fields. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "complete",
        "description": "Backend: Implement PlayerState Repository and API Endpoints",
        "details": "In `backend/`: \n1. Create `backend/src/mus/domain/entities/player_state.py` defining `PlayerState` SQLModel model as per PRD section 3.6.\n2. Implement `backend/src/mus/infrastructure/persistence/sqlite_player_state_repository.py` with methods `save_state(state: PlayerState)` and `load_state() -> PlayerState | None`. Use async SQLModel for database interactions with the `player_state` table (ensure table is created in database initialization if not already). Store only one row for player state, e.g., with `id=1`.\n3. Create `backend/src/mus/application/use_cases/manage_player_state_use_case.py` with methods to save and load player state, using the repository.\n4. In `backend/src/mus/infrastructure/api/routers/player_router.py` (create file), implement `POST /api/v1/player/state` and `GET /api/v1/player/state` endpoints using the use case. Use DTOs defined previously for request/response. Register this router in `backend/src/mus/main.py`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "complete",
        "description": "Refactor Backend Configuration: Hardcode Settings and Simplify `config.py`",
        "details": "Update `backend/src/mus/config.py` so the `Config` model only contains `SECRET_KEY = os.getenv(\"SECRET_KEY\", \"default-insecure-secret-key\")`. Other configurations must be hardcoded directly in their respective modules: 1. `LOGIN_SECRET` (e.g., `\"default-login-secret\"`) in `backend/src/mus/infrastructure/api/auth.py`. 2. Database path: In `backend/src/mus/infrastructure/database.py`, define `DATABASE_FILE_PATH = \"mus_database.db\"`. Ensure any parent directory for this path (if not root, e.g., if it were `\"data/mus_database.db\"`) is created using `os.makedirs(os.path.dirname(DATABASE_FILE_PATH), exist_ok=True)` before engine creation. Update `create_async_engine` to use `f\"sqlite+aiosqlite:///{DATABASE_FILE_PATH}\"`. Assistant has to use `context7` MCP server to reference fresh documentation for `aiosqlite` and its integration with SQLAlchemy/SQLModel for engine creation, specifically regarding connection parameters if any are needed beyond the URL. 3. `MUSIC_DIR` (e.g., `\"./music\"`) directly in `backend/src/mus/infrastructure/scanner/file_system_scanner.py` (or where it's primarily used, like in `ScanTracksUseCase` instantiation if it's passed there). Ensure `os.makedirs` is used for this hardcoded path. 4. `COVERS_DIR` (e.g., `\"./data/covers\"`) directly in the cover processing service (e.g., `backend/src/mus/infrastructure/scanner/cover_processor.py`). Ensure `os.makedirs` is used for this hardcoded path. Remove these configurations from `backend/src/mus/config.py`'s Pydantic model and any `os.getenv` calls for them. Update any tests that relied on these being configurable. Ensure `.gitignore` correctly ignores `mus_database.db` if it's at the project root or a predictable path not already covered. Apply relevant rules from `.cursor/rules/python.mdc`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings.",
        "files_to_modify": "`backend/src/mus/config.py,backend/src/mus/infrastructure/api/auth.py,backend/src/mus/infrastructure/database.py,backend/src/mus/infrastructure/scanner/file_system_scanner.py,backend/src/mus/infrastructure/scanner/cover_processor.py,.gitignore`"
      },
      {
        "status": "complete",
        "description": "Update Backend Cover Processing (Original and Small WebP)",
        "details": "Modify the cover processing service (e.g., `CoverProcessor` or its equivalent in `backend/src/mus/infrastructure/scanner/`) to: 1. Generate an 'original' WebP cover by converting the input image data to WebP format while maintaining its original dimensions. 2. Generate a 'small' WebP cover, resizing to a fixed dimension (e.g., 80x80 pixels) and converting to WebP. 3. Remove any logic for generating 'medium' sized covers. 4. Update cover image file naming to reflect these changes (e.g., `{track_id}_original.webp`, `{track_id}_small.webp`). Apply relevant rules from `.cursor/rules/python.mdc`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings.",
        "files_to_modify": "`backend/src/mus/infrastructure/scanner/cover_processor.py`"
      },
      {
        "status": "complete",
        "description": "Update Backend Cover API Endpoint and TrackDTO for New Cover URLs",
        "details": "1. In `backend/src/mus/application/dtos/track.py`, modify the `TrackDTO` Pydantic model: remove the `cover_medium_url` field, and add `cover_original_url: Optional[str] = None`. The `cover_small_url` field remains. 2. Update the cover API endpoint `GET /api/v1/tracks/{track_id}/covers/{size}.webp` in `backend/src/mus/infrastructure/api/routers/track_router.py` (or its new location if refactored from `R3W7` climb): change `size` parameter validation to accept 'original' and 'small'. Remove support for 'medium'. Ensure it serves the correct WebP files based on the new naming convention. 3. Update the logic responsible for populating `TrackDTO` instances (likely within the API router handling `GET /api/v1/tracks`) to: correctly construct `cover_original_url` (e.g., `/api/v1/tracks/{track_id}/covers/original.webp`) and `cover_small_url` (e.g., `/api/v1/tracks/{track_id}/covers/small.webp`) if `has_cover` is true. 4. Adjust any associated API schema definitions (e.g., in `backend/src/mus/infrastructure/api/schemas.py`) if they directly reference or re-export `TrackDTO`. Apply relevant rules from `.cursor/rules/python.mdc`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings.",
        "files_to_modify": "`backend/src/mus/application/dtos/track.py,backend/src/mus/infrastructure/api/routers/track_router.py,backend/src/mus/infrastructure/api/schemas.py`"
      },
      {
        "status": "todo",
        "description": "Implement SQLite UPSERT for PlayerState Repository",
        "details": "Refactor the `save_state` method in `backend/src/mus/infrastructure/persistence/sqlite_player_state_repository.py`. Modify it to use SQLite's `INSERT ... ON CONFLICT DO UPDATE` statement. The conflict target should be the `id` column of the `player_state` table (the `PlayerState` SQLModel in `backend/src/mus/domain/entities/player_state.py` should ensure `id=1` is the primary key). All fields of the `PlayerState` should be updated on conflict. Apply relevant rules from `.cursor/rules/python.mdc`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings.",
        "files_to_modify": "`backend/src/mus/infrastructure/persistence/sqlite_player_state_repository.py,backend/src/mus/domain/entities/player_state.py`"
      },
      {
        "status": "todo",
        "description": "Implement SQLite UPSERT for Track Entities (SQLModel, Repository, Use Case)",
        "details": "1. In `backend/src/mus/domain/entities/track.py`, update the `Track` SQLModel: add `unique=True` to the `Field` definition for `file_path` to enforce a unique constraint at the database level. 2. In `backend/src/mus/infrastructure/persistence/sqlite_track_repository.py`, implement a new method `async def upsert_track(self, track_data: Track) -> Track:`. This method should perform an `INSERT` operation for the `Track`. If a conflict occurs on the `file_path` (due to the unique constraint), it should `UPDATE` the existing record's `title`, `artist`, `duration`, and `has_cover` fields using the values from `track_data` (e.g., using `excluded.title`). The `id` and `added_at` fields of an existing record MUST NOT be updated. The method should return the final state of the track from the database (either newly inserted or updated and then re-fetched/refreshed). 3. In `backend/src/mus/application/use_cases/scan_tracks_use_case.py` (or its equivalent if refactored), replace the logic of checking `exists_by_path` and then calling `add` with a direct call to the new `upsert_track` method from the track repository. Ensure the `track_id` obtained from the `upsert_track` operation is correctly used for subsequent cover processing logic. Apply relevant rules from `.cursor/rules/python.mdc`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings.",
        "files_to_modify": "`backend/src/mus/domain/entities/track.py,backend/src/mus/infrastructure/persistence/sqlite_track_repository.py,backend/src/mus/application/use_cases/scan_tracks_use_case.py`"
      },
      {
        "status": "todo",
        "description": "Update Frontend Track Type and Components for New Cover URLs",
        "details": "1. In `frontend/src/types/index.ts` (or `frontend/src/types/api.types.ts`), modify the TypeScript `Track` interface: remove `cover_medium_url` and add `cover_original_url: string | null;`. The `cover_small_url` field remains. 2. Update `frontend/src/components/domain/TrackItem.tsx`: ensure it uses `track.cover_small_url` for displaying the cover art in the track list. 3. Update `frontend/src/components/layout/PlayerFooter.tsx`: if it displays a larger version of the current track's cover, modify it to use `currentTrack.cover_original_url`. Review and adjust any CSS if the original cover dimensions (which can vary) affect the layout. 4. Check any other frontend components that display track covers and update them to use either `cover_small_url` or `cover_original_url` as appropriate for the context. Apply relevant rules for TypeScript/React development (e.g., from `.cursor/rules/ts.mdc` or `.cursor/rules/react.mdc` if they exist). --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings.",
        "files_to_modify": "`frontend/src/types/index.ts,frontend/src/components/domain/TrackItem.tsx,frontend/src/components/layout/PlayerFooter.tsx`"
      },
      {
        "status": "todo",
        "description": "Update Tests and Run Linters/Formatters",
        "details": "Update backend tests (`backend/tests/`) to cover: new cover API endpoints (handling 'original' and 'small' sizes, proper DTO structure with new URLs), `CoverProcessor` output (original and small WebP), `PlayerStateRepository` UPSERT logic, `TrackRepository` UPSERT logic (verify fields updated/preserved correctly, unique constraint on `file_path`), and `ScanTracksUseCase` adaptation for `upsert_track`. Update frontend tests (`frontend/src/`) for components displaying covers (`TrackItem`, `PlayerFooter`). After all changes, run `make ci`. The assistant must ensure `make ci` completes without any errors or warnings, iteratively fixing issues if they arise. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings.",
        "files_to_modify": "`backend/tests/api/test_track_api.py,backend/tests/infrastructure/test_cover_processor.py,backend/tests/application/test_scan_tracks_use_case.py,backend/tests/persistence/test_sqlite_player_state_repository.py,backend/tests/persistence/test_sqlite_track_repository.py,frontend/src/components/domain/TrackItem.test.tsx,frontend/src/components/layout/PlayerFooter.test.tsx`",
        "rest": true
      },
      {
        "status": "todo",
        "description": "Backend: Implement Core Track Endpoints (List, Stream, Covers)",
        "details": "In `backend/src/mus/infrastructure/api/routers/track_router.py` (create or use existing if structure allows):\n1. Implement `GET /api/v1/tracks`: Fetches all tracks from `SQLiteTrackRepository` and returns them using the `Track` DTO. Ensure tracks are ordered appropriately (e.g., by `added_at DESC` as per PRD).\n2. Implement `GET /api/v1/tracks/{track_id}/stream`: Fetches track by ID from repository. If found, streams the audio file specified by `track.file_path`. Handle potential `FileNotFoundError`. Use appropriate `FileResponse` with correct media type. Implement HTTP Range request handling for efficient streaming if feasible, or basic streaming otherwise.\n3. Implement `GET /api/v1/tracks/{track_id}/covers/{size}.webp`: Fetches track by ID. If `track.has_cover` is true, construct path to the cover image (e.g., `data/covers/{track_id}_{size}.webp`) and serve it using `FileResponse`. If no cover, serve a placeholder. Validate `size` parameter (`small`, `medium`). Register this router in `backend/src/mus/main.py`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Backend: Implement Track Scanning Logic (Adapting Legacy)",
        "details": "In `backend/`:\n1. Adapt `MetadataExtractor` from `legacy/backend/src/mus/application/components/metadata_extractor.py` into `backend/src/mus/infrastructure/scanner/metadata_extractor.py`. Ensure it follows hexagonal principles and uses async methods if appropriate. It should return title, artist, duration, added_at (from file mtime), and raw cover_data (bytes).\n2. Adapt `CoverService` (renamed to `CoverProcessor` or similar) from `legacy/backend/src/mus/application/services/cover_service.py` into `backend/src/mus/infrastructure/scanner/cover_processor.py`. It should take track_id and image_data, resize to 'small' and 'medium' (as per PRD 3.5), save as WEBP to `data/covers/`, and return a boolean indicating success.\n3. Adapt `FileSystemScanner` from `legacy/backend/src/mus/infrastructure/scan/file_system_scanner.py` into `backend/src/mus/infrastructure/scanner/file_system_scanner.py`. It should find music files in specified directories.\n4. Create/Adapt `ScanTracksUseCase` in `backend/src/mus/application/use_cases/scan_tracks_use_case.py`. This use case will orchestrate: calling `FileSystemScanner`, then for each new file, calling `MetadataExtractor`. If metadata is extracted, it creates a `Track` domain entity and saves it via `SQLiteTrackRepository`. If cover data is present, it calls `CoverProcessor` and then updates the track's `has_cover` flag in the repository. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Backend: Implement Scan Endpoint and Finalize API Routers",
        "details": "In `backend/`:\n1. In `track_router.py` (or a dedicated `scan_router.py`), implement `POST /api/v1/scan`. This endpoint should trigger the `ScanTracksUseCase` to perform a full rescan of the music library. It should return a success message or status.\n2. Ensure all routers (`auth_router.py`, `player_router.py`, `track_router.py`) are correctly included in `backend/src/mus/main.py`.\n3. Review all API endpoints against PRD section 3.5 and ensure they are implemented as specified, using the defined DTOs. For now, these endpoints should not require JWT authentication, as per PRD section 3.7 Exception for Tauri access. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings.",
        "rest": true
      },
      {
        "status": "todo",
        "description": "Frontend: Initialize Vite Project and Core Dependencies",
        "details": "In `frontend/` directory (ensure it's empty or safely deletable first):\n1. Run `npx create-vite@latest . --template react-ts` to initialize the project.\n2. Install core production dependencies: `npm install zustand @tanstack/react-query date-fns lucide-react class-variance-authority clsx tailwind-merge`. \n3. Install dev dependencies: `npm install --save-dev tailwindcss postcss autoprefixer @types/react @types/react-dom eslint prettier eslint-plugin-react-hooks eslint-plugin-react-refresh @typescript-eslint/eslint-plugin @typescript-eslint/parser vite-tsconfig-paths` (or similar standard ESLint/Prettier setup for Vite/React/TS). Consider `eslint-config-standard-with-typescript` or equivalent. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Frontend: Setup Tailwind CSS and Shadcn/UI",
        "details": "In `frontend/`:\n1. Initialize Tailwind CSS: `npx tailwindcss init -p`. Configure `frontend/tailwind.config.js` (or `.ts`): set up `content` paths to include all `src/**/*.{js,jsx,ts,tsx}` files. Define a basic dark theme as default in the theme configuration. Add Tailwind directives (`@tailwind base; @tailwind components; @tailwind utilities;`) to `frontend/src/index.css` (or `main.css`).\n2. Initialize Shadcn/UI: `npx shadcn-ui@latest init`. During setup, confirm TypeScript usage, style (e.g., Default), base color (e.g., Slate), CSS variables, paths for `tailwind.config.js`, `globals.css` (likely `src/index.css`), components (`@/components`), and utils (`@/lib/utils`).\n3. Install a few example Shadcn/UI components to verify setup: `npx shadcn-ui@latest add button card sonner`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Frontend: Configure Vite, ESLint, Prettier, and Project Structure",
        "details": "In `frontend/`:\n1. Configure `vite.config.ts`: Add `vite-tsconfig-paths` plugin for path aliases (e.g., `@/*` mapped to `src/*`).\n2. Update `tsconfig.json`: Ensure `baseUrl` and `paths` are set up to match Vite path aliases. Add `\"esModuleInterop\": true, \"forceConsistentCasingInFileNames\": true, \"skipLibCheck\": true` if not present.\n3. Setup ESLint: Create or modify `eslint.config.js` (or `.eslintrc.js/.cjs`). Use a standard configuration for React/TypeScript (e.g., `eslint-plugin-react`, `@typescript-eslint/eslint-plugin`, `eslint-plugin-jsx-a11y`). Add script to `package.json`: `\"lint\": \"eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0\"`.\n4. Setup Prettier: Create `.prettierrc.json` with desired formatting rules. Add script to `package.json`: `\"format\": \"prettier --write .\"`.\n5. Create directory structure as per PRD 3.2: `src/pages`, `src/components/ui` (for Shadcn), `src/components/layout`, `src/components/domain`, `src/hooks`, `src/services`, `src/store`, `src/types`, `src/utils`, `src/assets`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Frontend: Define Core Types and Zustand Stores",
        "details": "In `frontend/src/`:\n1. Create `types/index.ts` (or `types/api.types.ts`). Define TypeScript interfaces for `Track` (matching backend DTO: id, title, artist, duration, file_path, added_at, has_cover, cover_small_url, cover_medium_url) and `PlayerState` (matching backend DTO: current_track_id, progress_seconds, volume_level, is_muted).\n2. Create `store/playerStore.ts`: Implement a Zustand store for player state (`currentTrackId: string | number | null`, `isPlaying: boolean`, `currentTime: number`, `duration: number`, `volume: number`, `isMuted: boolean`). Include actions: `playTrack(trackId, duration)`, `togglePlayPause`, `setCurrentTime`, `setVolume`, `toggleMute`, `setTrackListAndCurrentTrack(tracks, currentTrackId)`.\n3. Create `store/trackStore.ts`: Implement a Zustand store for managing the list of `Track` objects (`tracks: Track[]`) and potentially the `currentPlayingTrack: Track | null`. Include actions `setTracks(tracks: Track[])`. (This could be merged with playerStore if simple enough). --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Frontend: Setup API Client and Track/Player Services with TanStack Query",
        "details": "In `frontend/src/services/`:\n1. Create `apiClient.ts`: Initialize and export a `QueryClient` instance from `@tanstack/react-query`. Optionally, configure a base `fetch` wrapper or Axios instance if common headers/error handling are needed.\n2. Create `trackService.ts`:\n   - `useFetchTracks()`: A `useQuery` hook to fetch all tracks from `GET /api/v1/tracks`.\n   - `useFetchPlayerState()`: A `useQuery` hook to fetch player state from `GET /api/v1/player/state`.\n   - `useSavePlayerState()`: A `useMutation` hook to post player state to `POST /api/v1/player/state`.\n   - `useTriggerScan()`: A `useMutation` hook for `POST /api/v1/scan`. Ensure `useFetchTracks` query is invalidated on success. \nProvide these hooks from `QueryClientProvider` in `App.tsx` or `main.tsx`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Frontend: Implement PlayerFooter Component (Layout and Basic Controls)",
        "details": "In `frontend/src/components/layout/PlayerFooter.tsx`:\n1. Create the main layout for the footer using Shadcn UI components (e.g., `Card` for the footer bar) and Tailwind CSS for styling. It should be fixed to the bottom.\n2. Left zone: Display current track's cover art (use `<img>` tag, source from `PlayerStore`), title, and artist.\n3. Center zone (Playback Controls): Add Shadcn `Button` components for 'Previous', 'Play/Pause', 'Next'. Use `lucide-react` icons for these buttons.\n4. Center zone (Progress Bar): Implement a seekable progress bar. Use a Shadcn `Slider` component or a custom styled `div`. Display current time and total duration using `<span>` tags, formatted with `date-fns`.\n5. Right zone (Volume Control): Add a `Button` for 'Mute/Unmute' (using `lucide-react` icon). Implement a volume slider using Shadcn `Slider` or custom. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Frontend: Implement TrackList and TrackItem Components",
        "details": "In `frontend/src/components/domain/`:\n1. Create `TrackItem.tsx`: This component should display information for a single track (cover art, title, artist, duration). Use Shadcn `Card` or styled `divs`. Add a play button icon. Format duration using `date-fns`. Get cover art URL like `/api/v1/tracks/{track_id}/covers/small.webp`.\n2. Create `TrackList.tsx`: This component fetches tracks using `trackService.useFetchTracks()`. It then maps over the fetched tracks and renders a `TrackItem` for each. Handle loading and error states from `useQuery`. Style as a scrollable list. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Frontend: Connect UI to State and Services (Player Logic)",
        "details": "In `frontend/`:\n1. `PlayerFooter.tsx`: Connect Play/Pause, Next, Previous buttons to actions in `playerStore` and `trackStore`. When a track plays, its `audio.src` should point to `/api/v1/tracks/{track_id}/stream`. Progress bar should update based on `audio.currentTime` and `audio.duration`, and seeking should update `audio.currentTime`. Volume controls should update `audio.volume` and `audio.muted` properties and reflect in `playerStore`.\n2. `TrackItem.tsx`: Clicking the play button on a `TrackItem` should trigger an action in `playerStore` to start playing that track.\n3. `HomePage.tsx` (create in `src/pages/`): Assemble `TrackList` and `PlayerFooter`. This page will be the main view.\n4. `App.tsx`: Render `HomePage`. Wrap the app with `QueryClientProvider`.\n5. State Persistence: On relevant player state changes (current track, time, volume, mute), call `useSavePlayerState` mutation from `trackService` to persist state to the backend. Fetch initial state using `useFetchPlayerState` on app load and populate `playerStore`.\n6. Ensure dark theme is consistently applied using Tailwind CSS utility classes on all components. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings.",
        "rest": true
      },
      {
        "status": "todo",
        "description": "Frontend: Implement PWA Manifest and Basic Service Worker",
        "details": "In `frontend/`:\n1. Create `public/manifest.json` as per PRD section 2.1. It needs `name`, `short_name`, `icons` (provide sample 192x192 and 512x512 icons in `public/images/` or similar, update paths in manifest), `start_url`, `display`, `background_color`, `theme_color`.\n2. Create `src/service-worker.ts` (or `.js`). Implement `install` event to cache essential app shell assets (e.g., `index.html`, main CSS bundle, main JS bundle, `manifest.json`, key icons). Implement `activate` event to clear old caches. Implement `fetch` event with a cache-first strategy for these assets. Refer to `.cursor/rules/pwa-sw-cache-check.mdc` for guidance on what to cache.\n3. Register the service worker in `src/main.tsx`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Tauri: Initialize and Configure Tauri in Frontend Project",
        "details": "In `frontend/`:\n1. Add Tauri dependencies: `npm install --save-dev @tauri-apps/cli @tauri-apps/api`.\n2. Initialize Tauri: `npx tauri init`. When prompted:\n   - App name: `Mus Next Generation` (or user preference)\n   - Window title: `Mus`\n   - Web asset path (relative to `src-tauri`): `../dist` (assuming Vite builds to `frontend/dist`)\n   - Dev server URL: `http://localhost:5173` (or your Vite dev server URL).\n3. Configure `frontend/src-tauri/tauri.conf.json` (or `Tauri.toml`):\n   - Verify `build.devPath` and `build.distDir` are correct.\n   - Set initial window properties (title, width, height e.g. 1200x800).\n   - In `tauri.allowlist`, ensure `http.all: true` or `http.scope: [\"http://localhost:8000/*\"]` (if backend runs on port 8000) is enabled so Tauri can make API calls to the backend. The backend API endpoints are not JWT protected for Tauri access (PRD 3.7). --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Tauri: Test Development Workflow and Build",
        "details": "In `frontend/`:\n1. Start the Vite dev server: `npm run dev`.\n2. In a separate terminal, run the Tauri dev app: `npx tauri dev`. Verify the frontend loads correctly within the Tauri window and can fully interact with the backend API (fetch tracks, play music, save state).\n3. Stop the dev processes. Build the frontend assets: `npm run build`.\n4. Build the Tauri application: `npx tauri build`. Verify it creates an executable/installer for your OS in `frontend/src-tauri/target/release/`.\n5. Document any potential native features (media keys, notifications) for future implementation in `ARCHITECTURE.md` under a 'Tauri Future Considerations' section, as per PRD section 2.1. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings.",
        "rest": true
      },
      {
        "status": "todo",
        "description": "Docker: Create Dockerignore Files and Backend Dockerfile",
        "details": "1. Create/Update `backend/.dockerignore`: Exclude `.venv`, `__pycache__`, `*.pyc`, `*.log`, `data/` (if SQLite DB is there and not mounted as volume in prod), etc.\n2. Create/Update `frontend/.dockerignore`: Exclude `node_modules/`, `dist/`, `src-tauri/target/`, `*.log`, etc.\n3. Create/Update root `.dockerignore`: Add `.git`, `.vscode`, `.idea`, `docker/`, `*.md` (if not needed in image), etc.\n4. Create `docker/backend.Dockerfile`:\n   - Use an official Python slim base image (e.g., `python:3.12-slim`).\n   - Set `WORKDIR /app/backend`.\n   - Copy `backend/requirements.txt` and `backend/pyproject.toml`.\n   - Install `uv`.\n   - Install dependencies using `uv pip install --no-cache-dir --system -r requirements.txt`.\n   - Copy the rest of the `backend/src` directory to `/app/backend/src`.\n   - Expose port 8000.\n   - `CMD [\"uvicorn\", \"src.mus.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Docker: Create Production Dockerfile (Multi-stage)",
        "details": "Create `docker/production.Dockerfile`:\n```Dockerfile\n# Stage 1: Build frontend assets\nFROM node:20-alpine AS frontend-builder\nWORKDIR /app/frontend\nCOPY frontend/package.json frontend/package-lock.json* ./\nRUN npm install\nCOPY frontend/ ./\nRUN npm run build\n\n# Stage 2: Setup backend\nFROM python:3.12-slim\nWORKDIR /app\n\n# Install uv and Python dependencies\nCOPY backend/requirements.txt backend/pyproject.toml /app/backend/\nRUN apt-get update && apt-get install -y curl && \\\n    curl -LsSf https://astral.sh/uv/install.sh | sh && \\\n    /root/.cargo/bin/uv pip install --no-cache-dir --system -r /app/backend/requirements.txt && \\\n    apt-get purge -y --auto-remove curl && rm -rf /var/lib/apt/lists/*\nENV PATH=\"/root/.cargo/bin:${PATH}\"\n\nCOPY backend/src /app/backend/src\n\n# Copy built frontend assets from builder stage\nCOPY --from=frontend-builder /app/frontend/dist /app/backend/static_root\n# (Backend FastAPI will need to be configured to serve static files from /app/backend/static_root)\n\n# Create data directory for SQLite DB and covers if not using external volumes\nRUN mkdir -p /app/data/covers\nVOLUME /app/data\nVOLUME /music # For music library access\n\nEXPOSE 8000\nENV PYTHONUNBUFFERED=1\nCMD [\"uvicorn\", \"backend.src.mus.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\nNote: The backend FastAPI app needs to be configured to serve static files from `/app/backend/static_root/` at the frontend's root path (e.g., `/`). This typically involves `app.mount(\"/\", StaticFiles(directory=\"/app/backend/static_root\", html=True), name=\"static-frontend\")` in `backend/src/mus/main.py` for production image. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Docker: Create Docker Compose for Local Development",
        "details": "Create `docker-compose.yml` in the project root:\n```yaml\nservices:\n  backend:\n    build:\n      context: .\n      dockerfile: docker/backend.Dockerfile # For dev, could also mount code and run uvicorn directly\n    ports:\n      - \"8000:8000\"\n    volumes:\n      - ./backend/src:/app/backend/src # Live reload for backend code\n      - ./data:/app/data # Persistent data for SQLite DB, covers\n      - ./music:/music:ro # Mount local music library (read-only)\n    environment:\n      - DATABASE_URL=sqlite:////app/data/mus.db\n      - MUSIC_DIR=/music\n      - COVERS_DIR=/app/data/covers\n      - SECRET_KEY=your_dev_secret_key # Use .env file for secrets in real dev\n      - LOGIN_SECRET=your_dev_login_secret\n    # depends_on: - db (if using separate db service)\n\n  frontend:\n    build:\n      context: ./frontend # Optional: can use a pre-built node image and run npm install/dev\n      dockerfile: Dockerfile # A simple frontend Dockerfile for dev if needed, or:\n    image: node:20-alpine # Or use a pre-built image\n    working_dir: /app/frontend\n    command: npm run dev -- --host # Ensure Vite dev server is accessible\n    ports:\n      - \"5173:5173\"\n    volumes:\n      - ./frontend:/app/frontend\n      - /app/frontend/node_modules # Named volume to persist node_modules\n    environment:\n      - VITE_API_BASE_URL=http://backend:8000 # If frontend needs to know backend URL\n\nvolumes:\n  data:\n  music:\n  frontend_node_modules:\n```\nAdjust `frontend` service as needed. If `docker/frontend.Dockerfile` is only for CI asset building, the `frontend` service in `docker-compose.yml` can directly use a `node` image and mount the code. Ensure environment variables for secrets are handled securely (e.g., `.env` files not committed). For `frontend` service, `command: npm run dev` assumes `package.json` has this script. `--host` flag for Vite is important to expose it outside the container. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Makefiles: Setup Root Makefile and Backend Targets",
        "details": "1. Update root `Makefile`: Ensure it includes `docker/makefiles/*.mk`. Define top-level `format`, `lint`, `test` targets that call service-specific targets.\n   Example `Makefile` inclusion: `include docker/makefiles/*.mk`\n   Example top-level target: `.PHONY: lint\nlint:\n\t@$(MAKE) backend-lint\n\t@$(MAKE) frontend-lint`\n2. Create/Update `docker/makefiles/backend.mk`:\n   - `backend-install`: `cd backend && uv pip install --system -r requirements.txt` (adjust if dev deps needed).\n   - `backend-dev`: `cd backend && uvicorn src.mus.main:app --reload --host 0.0.0.0 --port 8000`.\n   - `backend-lint`: `cd backend && uv run ruff check . && uv run ruff format --check .`.\n   - `backend-format`: `cd backend && uv run ruff format . && uv run ruff check . --fix`.\n   - `backend-test`: `cd backend && uv run pytest tests/`.\n   - Ensure these commands match actual project setup (e.g. `src` vs `.` for ruff). --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Makefiles: Setup Frontend, Tauri, and Docker Targets",
        "details": "1. Create/Update `docker/makefiles/frontend.mk`:\n   - `frontend-install`: `cd frontend && npm install`.\n   - `frontend-dev`: `cd frontend && npm run dev`.\n   - `frontend-build`: `cd frontend && npm run build`.\n   - `frontend-lint`: `cd frontend && npm run lint` (ensure `lint` script exists in `frontend/package.json` for ESLint/Stylelint).\n   - `frontend-format`: `cd frontend && npm run format` (ensure `format` script exists for Prettier).\n   - `frontend-test`: `cd frontend && npm run test` (ensure `test` script exists for Vitest).\n   AI Assistant: Ensure corresponding scripts (`dev`, `build`, `lint`, `format`, `test`) are defined in `frontend/package.json`.\n2. Create `docker/makefiles/tauri.mk`:\n   - `tauri-dev`: `cd frontend && npx tauri dev`.\n   - `tauri-build`: `cd frontend && npx tauri build`.\n3. Create `docker/makefiles/docker.mk` (or consolidate from existing `project.mk`):\n   - `docker-build-prod`: `docker build -t mus-app:latest -f docker/production.Dockerfile .`.\n   - `docker-up`: `docker-compose up -d`.\n   - `docker-down`: `docker-compose down`.\n   - `docker-logs`: `docker-compose logs -f`.\n   - `docker-rebuild`: `docker-compose build --no-cache`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings.",
        "rest": true
      },
      {
        "status": "todo",
        "description": "Backend Tests: Setup and Authentication Tests",
        "details": "In `backend/tests/`:\n1. Configure `pyproject.toml [tool.pytest.ini_options]` (or `pytest.ini`) for `asyncio_mode = auto` (or `strict`). Ensure `httpx` and `pytest-asyncio` are dev dependencies.\n2. Create `tests/conftest.py`: Define fixtures for `TestClient(app)`, an async SQLModel engine for an in-memory SQLite DB, and session management for tests.\n3. Authentication Tests (`tests/api/test_auth_api.py`): Verify `POST /api/v1/auth/login-via-secret/{secret_key}` (success with cookie set, failure with wrong key). Test a sample protected endpoint (if any added later) with and without a valid JWT cookie. Note: The PRD implies most data endpoints aren't protected for Tauri. Current `test_auth.py` can be expanded if needed. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Backend Tests: API Endpoint Tests (Tracks, Player State, Scan)",
        "details": "In `backend/tests/api/`:\n1. `test_track_api.py`:\n   - Test `GET /api/v1/tracks` (empty list, list with multiple tracks, correct DTO structure).\n   - Test `GET /api/v1/tracks/{track_id}/stream` (successful stream, track not found 404, file for track not found leads to 404).\n   - Test `GET /api/v1/tracks/{track_id}/covers/{size}.webp` (small/medium success, track has no cover placeholder, track not found 404, invalid size 400).\n   - Test `POST /api/v1/scan` (successful trigger, check response, mock `ScanTracksUseCase` to verify it's called).\n2. `test_player_state_api.py`:\n   - Test `POST /api/v1/player/state` (valid data saves correctly, invalid data returns 422).\n   - Test `GET /api/v1/player/state` (returns existing state, returns default/empty state if none saved). --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Backend Tests: Repository and Use Case Unit/Integration Tests",
        "details": "In `backend/tests/`:\n1. Repository Tests (`tests/persistence/test_sqlite_track_repository.py`, `test_sqlite_player_state_repository.py`):\n   - Test all methods of `SQLiteTrackRepository`: `add`, `get_by_id`, `get_all`, `exists_by_path`, `set_cover_flag`, `clear_all_tracks`. Test with in-memory SQLite.\n   - Test `SQLitePlayerStateRepository`: `save_state`, `load_state`.\n2. Use Case Tests (`tests/application/test_scan_tracks_use_case.py`, `test_manage_player_state_use_case.py`):\n   - Test `ScanTracksUseCase`: Mock its dependencies (scanner, metadata_reader, cover_processor, repository). Verify it correctly processes files, adds tracks, handles covers.\n   - Test `ManagePlayerStateUseCase` methods for saving and loading player state, mocking the repository.\n3. Infrastructure Tests (`tests/infrastructure/test_metadata_extractor.py`, `test_cover_processor.py`, `test_file_system_scanner.py`):\n   - Unit test `MetadataExtractor` with sample audio files (mocks or minimal real files) for various formats if possible. Test cover extraction.\n   - Unit test `CoverProcessor` with sample image data, verify output images are created correctly.\n   - Unit test `FileSystemScanner` with a mock file system structure.\n4. Run all backend tests with `make backend-test` and check for >80% coverage with `pytest --cov=src.mus backend/tests/`. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Frontend Tests: Setup Vitest and Basic Component/Store Tests",
        "details": "In `frontend/`:\n1. Test Setup: Install `vitest`, `@testing-library/react`, `@testing-library/jest-dom`, `jsdom`, `msw` (for API mocking). Configure `vite.config.ts` for Vitest (e.g., `test: { globals: true, environment: 'jsdom', setupFiles: './src/setupTests.ts' }`). Create `src/setupTests.ts` to import `@testing-library/jest-dom`.\n2. Add test scripts to `frontend/package.json`: `\"test\": \"vitest\"`, `\"coverage\": \"vitest run --coverage\"`.\n3. Zustand Store Tests (`src/store/playerStore.test.ts`, `src/store/trackStore.test.ts`): Test initial state, actions, and selectors for both stores.\n4. Basic Component Tests (`src/components/domain/TrackItem.test.tsx`): Render `TrackItem` with mock track data. Verify displayed info (title, artist, duration). Simulate click on play button and check if correct action/callback is triggered (mock an event handler prop). Test cover art display logic. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Frontend Tests: PlayerFooter, API Service, and Integration Tests",
        "details": "In `frontend/src/`:\n1. `PlayerFooter` Component Tests (`components/layout/PlayerFooter.test.tsx`): Render component. Test interactions with play/pause, next/prev, seek bar, volume controls. Mock Zustand store and verify actions are called.\n2. API Service Tests (`services/trackService.test.ts`): Use `msw` to mock backend API endpoints. Test `useFetchTracks`, `useFetchPlayerState`, `useSavePlayerState`, `useTriggerScan` hooks. Verify they call the correct API, handle responses, and manage query states (loading, error, success).\n3. Basic Integration Test (`pages/HomePage.test.tsx`): Render `HomePage`. Mock API responses with `msw`. Verify that `TrackList` displays tracks and `PlayerFooter` is present. Test a simple user flow: clicking a track in `TrackList` updates the `PlayerFooter` and triggers playback (mock audio playback itself). Aim for >70% coverage via `make frontend-test` (assuming it runs Vitest with coverage). --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "CI/CD: Update GitHub Workflows (Linters, Testers, Deploy)",
        "details": "In `.github/workflows/`:\n1. `linters.yml`:\n   - Modify/Create `backend-lint` job: Use `uv` for deps, run `make backend-lint` (which should include format check).\n   - Modify/Create `frontend-lint` job: Use Node.js setup, `npm install`, run `make frontend-lint` (which should include format check).\n   - Add `backend-test` job: Use `uv`, run `make backend-test`.\n   - Add `frontend-test` job: Use Node.js, `npm install`, run `make frontend-test`.\n   - (Optional) Add `tauri-build-check` job: Use Node.js, `npm install`, run `make tauri-build` to verify Tauri app packaging.\n   Ensure jobs run on PRs and pushes to `main`.\n2. `deploy.yml`:\n   - Ensure it triggers on `workflow_run` completion of `linters.yml` (and tests jobs within it) for `main` branch.\n   - Update Docker build step to use `docker/production.Dockerfile`: `file: docker/production.Dockerfile`.\n   - Tag image with `latest` and Git SHA.\n   - Ensure secrets for Docker Hub login are correctly used. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings.",
        "rest": true
      },
      {
        "status": "todo",
        "description": "Documentation: Update README.md and ARCHITECTURE.md",
        "details": "1. `README.md`: Update project overview, tech stack. Add detailed setup instructions for backend (uv, .env) and frontend (npm, .env if any). Instructions for running dev (backend server, frontend Vite server, `npx tauri dev`). Build instructions (`make backend-build`, `make frontend-build`, `make tauri-build`, `make docker-build-prod`). How to run linters (`make lint`) and tests (`make test`). Overview of new project structure (`backend/`, `frontend/`, `docker/`).\n2. `ARCHITECTURE.md`: Create or significantly update. Detail Frontend (Vite, React, TS, Zustand, Tailwind, Shadcn, TanStack Query, dir structure, PWA approach). Backend (FastAPI, SQLModel, Hexagonal Arch, Python, uv, API design principles, testing). Tauri (purpose, `tauri.conf.json` key aspects, how it wraps frontend, notes on future native features like media keys/notifications). Docker (overview of each Dockerfile, `docker-compose.yml` purpose). Authentication flow (web secret key, JWT cookie, Tauri direct access). Data models (`Track`, `PlayerState`). Key technical decisions made. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings."
      },
      {
        "status": "todo",
        "description": "Final Review, E2E Testing, and Refinements",
        "details": "Perform a thorough end-to-end testing session:\n1. **Web Version (Browser):** Test login via secret key. Full music playback functionality (play, pause, next, prev, seek, volume, mute). Track scanning trigger. Player state persistence (reload, close/reopen tab). Responsiveness on different screen sizes. Check console for errors.\n2. **Tauri Desktop App:** Launch app. Full music playback functionality. Track scanning trigger. Player state persistence (close/reopen app). Check for any desktop-specific issues.\n3. Code Review: Self-review or peer-review frontend and backend code against PRD, best practices, clarity, and maintainability. Check for adherence to `.cursor/rules/*.mdc`.\n4. UI/UX Refinement: Address any visual glitches, inconsistencies, or usability pain points in the frontend.\n5. Configuration Check: Double-check all `.env` examples, Docker configurations, `tauri.conf.json`, Makefile targets, and CI/CD workflow files for correctness.\n6. Dependency Audit: Remove any unused dependencies from `backend/pyproject.toml` and `frontend/package.json`.\n7. Final Checks: Run `make format`, `make lint`, and `make test` one last time to ensure all pass without issues. --- **Commenting Policy**: Write comment-free, self-documenting code. Use clear names & structure. Exceptionally rare, very short comments for unavoidable complexity (explain *why*, not *what*). This applies to all code entities including docstrings.",
        "rest": true
      }
    ]
  }
}
