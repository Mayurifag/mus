{
  "Climb": "FrR3",
  "moves": [
    {
      "status": "todo",
      "description": "Backend: Update PlayerState; Implement Periodic Background Scan with Refactored Worker & SSE Notifications",
      "details": "Revamp backend for new player state fields, periodic scanning, and SSE notifications. 1. PlayerState Entity/DTO/Repository/Tests Update: In `backend/src/mus/domain/entities/player_state.py` and `backend/src/mus/application/dtos/player_state.py`, add fields `is_shuffle: bool = Field(default=False)` and `is_repeat: bool = Field(default=False)`. Update `backend/src/mus/infrastructure/persistence/sqlite_player_state_repository.py`'s `save_state` method to handle these new fields, ensuring they are included in the `state_data` dictionary and the `stmt.on_conflict_do_update` set clause. Update associated tests in `backend/tests/persistence/test_sqlite_player_state_repository.py` and `backend/tests/api/test_player_state_api.py` to verify correct storage and retrieval of these new boolean flags. 2. Remove Manual Scan Functionality: Delete the file `backend/src/mus/infrastructure/api/routers/scan_router.py`. Remove its inclusion from `backend/src/mus/main.py`. Delete the test file `backend/tests/api/test_scan_api.py`. 3. Implement SSE Endpoint & Broadcaster: Create `backend/src/mus/infrastructure/api/sse_handler.py`. This module will contain: (a) A global list or set to manage active SSE client queues (e.g., `active_sse_clients: List[asyncio.Queue] = []`). (b) An SSE endpoint router (e.g., `GET /api/v1/events/track-updates`) using FastAPI's `StreamingResponse` with `media_type=\"text/event-stream\"`. This handler will create an `asyncio.Queue`, add it to `active_sse_clients`, and then `yield` messages from this queue in the event-stream format (e.g., `f\"data: {json.dumps(event_data)}\\n\\n\"`). It must handle client disconnection by removing the queue from `active_sse_clients`. (c) A global SSE broadcasting utility function (e.g., `async def broadcast_sse_event(event_data: dict):`) that iterates through `active_sse_clients` and puts the `event_data` into each queue. Add this SSE router to `backend/src/mus/main.py`. 4. Implement Periodic Background Scanner Worker: Create `backend/src/mus/infrastructure/tasks/background_scanner.py`. Implement a `PeriodicScanner` class. Its constructor should accept a session factory (like `get_session_generator` from `database.py`), a `ScanTracksUseCase` factory function (a function that can create `ScanTracksUseCase` with all its dependencies given a session), the `broadcast_sse_event` utility, and a scan interval (e.g., 60 seconds). It should have `async def start(self)` and `async def stop(self)` methods. The `start` method will launch an `asyncio.Task` for an internal `_run_periodic_scan` method. The `_run_periodic_scan` method will be an infinite loop: (a) Obtain an `AsyncSession` using the session factory. (b) Instantiate `ScanTracksUseCase` using its factory and the session. (c) Call `await use_case.scan_directory()`. (d) Handle any exceptions from `scan_directory()` by logging them and continuing the loop. (e) `await asyncio.sleep(self.scan_interval)`. The `stop` method should cancel the asyncio task and await its completion. 5. `main.py` `lifespan` Refactor: Modify the `lifespan` startup event in `backend/src/mus/main.py`. It must *retain* DB reset (`SQLModel.metadata.drop_all`, `SQLModel.metadata.create_all`) and cover cleaning (`shutil.rmtree`, `os.makedirs` for `./data/covers`) as unconditional startup operations happening *before* scanner initialization. After DB/cover setup, instantiate `PeriodicScanner` (passing the necessary factories and `broadcast_sse_event` from `sse_handler.py`). Call `await periodic_scanner.start()`. On shutdown (yield part of lifespan), call `await periodic_scanner.stop()`. 6. `ScanTracksUseCase` Adaptation: Modify `ScanTracksUseCase` in `backend/src/mus/application/use_cases/scan_tracks_use_case.py`. After processing tracks (e.g., at the end of `scan_directory`, if changes were made or simply on completion), it should call the global `broadcast_sse_event` function (e.g., `await broadcast_sse_event({\"type\": \"tracks_updated\"})`). This function will now be passed into the `ScanTracksUseCase` or its factory, rather than being imported directly, if it's part of the SSE handler utilities. For simplicity, the use case might be constructed with the `broadcast_sse_event` function itself as a dependency. 7. Testing: (a) Update backend tests for `PlayerState` entity, DTO, repository, and API to include `is_shuffle` and `is_repeat`. (b) Create `backend/tests/api/test_sse_handler.py` for integration tests for the SSE endpoint: test client connection, event reception (mocking the broadcaster by directly putting events into a captured queue), and client disconnection handling. (c) Create `backend/tests/infrastructure/tasks/test_background_scanner.py`. Unit test `PeriodicScanner` for: correct initialization, `start` creating a task, `stop` cancelling the task, the loop calling scan logic (mocked `ScanTracksUseCase.scan_directory`) and `asyncio.sleep`, and robust error logging/continuation within the scan cycle. (d) Update `backend/tests/test_main_startup.py` to verify DB reset and cover cleaning. Verify `PeriodicScanner` instantiation and its `start()` method is called. Mock and verify `PeriodicScanner.stop()` is called on shutdown. (e) Update `backend/tests/application/test_scan_tracks_use_case.py` to verify that `ScanTracksUseCase` calls the `broadcast_sse_event` function (mock the broadcaster utility passed to it). Ensure `make ci` passes all tests and linters.",
      "rules_filepaths_to_follow": "`.cursor/rules/python.mdc,.cursor/rules/makefile_commands.mdc`",
      "filepaths_to_modify": "`backend/src/mus/domain/entities/player_state.py,backend/src/mus/application/dtos/player_state.py,backend/src/mus/infrastructure/persistence/sqlite_player_state_repository.py,backend/tests/persistence/test_sqlite_player_state_repository.py,backend/tests/api/test_player_state_api.py,backend/src/mus/main.py,backend/src/mus/infrastructure/api/sse_handler.py,backend/tests/api/test_sse_handler.py,backend/src/mus/application/use_cases/scan_tracks_use_case.py,backend/tests/application/test_scan_tracks_use_case.py,backend/tests/test_main_startup.py,backend/src/mus/infrastructure/tasks/background_scanner.py,backend/tests/infrastructure/tasks/test_background_scanner.py`",
      "rest": "true"
    },
    {
      "status": "todo",
      "description": "Frontend: Core Setup - Dependencies, Encapsulated xior API Client, Coverage, CSS/Icon Verification",
      "details": "Perform foundational frontend setup and refactoring. 1. Dependencies: RUN `make front-npm-install ARGS=xior`, RUN `make front-npm-dev-install ARGS=@vitest/coverage-v8`. 2. `apiClient.ts` Refactor: Entirely refactor `frontend/src/lib/services/apiClient.ts`. Instantiate and export a single, global `xior` instance. Configure its `baseURL` (dev: `http://localhost:8000/api/v1`, prod: `/api/v1`). All API functions (`fetchTracks`, `fetchPlayerState`, `savePlayerState`, `getStreamUrl`; `triggerScan` is removed) must use this `xior` instance and primarily return/handle `response.data`. Add basic console error logging for failed API requests within this file. No other frontend files should make direct `xior` or `fetch` calls. Add a new function `connectTrackUpdateEvents(onMessageCallback: (eventData: any) => void): EventSource` that establishes an `EventSource` connection to the backend's SSE endpoint (`/api/v1/events/track-updates`) and calls `onMessageCallback` with parsed event data (ensure `JSON.parse(event.data)` is used). It should handle basic error/reconnection logic for the EventSource (log errors, EventSource handles reconnection by default). Write comprehensive unit tests for all `apiClient.ts` functions, mocking `xior` and `EventSource`. 3. Vite & Coverage: Update `frontend/vite.config.ts` for Vitest coverage: `test: { coverage: { provider: 'v8', reporter: ['text', 'json', 'html'], include: ['src/lib/**/*.{ts,svelte}', 'src/routes/**/*.{ts,svelte}'], exclude: ['src/**/*.test.{ts,svelte}', 'src/**/*.spec.{ts,svelte}', 'src/**/__tests__', 'src/app.d.ts', 'src/vite-env.d.ts'] } }`. Add `\"test:coverage\": \"vitest run --coverage\"` to `frontend/package.json` scripts. 4. CSS & Icon Verification: Review/fix `frontend/src/app.css`, `frontend/tailwind.config.js`. Solidify 3-color dark theme via CSS variables as defined in `app.css`. Ensure Tailwind utilities and Shadcn components use these correctly. Verify `lucide-svelte` icons render. Fix pre-existing style/icon issues. Minimal custom CSS outside Tailwind utilities and `app.css` global definitions.",
      "rules_filepaths_to_follow": "`.cursor/rules/json.mdc,.cursor/rules/typescript.mdc,.cursor/rules/svelte.mdc,.cursor/rules/css.mdc,.cursor/rules/makefile_commands.mdc`",
      "filepaths_to_modify": "`frontend/package.json,frontend/vite.config.ts,frontend/src/lib/services/apiClient.ts,frontend/src/lib/services/apiClient.test.ts,frontend/src/app.css,frontend/tailwind.config.js`",
      "rest": "true"
    },
    {
      "status": "todo",
      "description": "Frontend: Implement Main Application Layout Shell (Desktop & Mobile) with Minimal Custom CSS",
      "details": "Develop main Svelte layout components, prioritizing Tailwind CSS. 1. Main Layout (`frontend/src/routes/(app)/+layout.svelte`): Desktop: Two-column area above footer (Main Content for `<slot />`, Right Sidebar). Footer fixed (`h-24`). Main content/sidebar fill `h-[calc(100vh-6rem)]`. Mobile: Main content full width, sidebar hidden (to be triggered by a button in PlayerFooter). Use Tailwind Flexbox/Grid. 2. Right Sidebar (`frontend/src/lib/components/layout/RightSidebar.svelte`): Style: `w-64` (desktop), `bg-neutral-900` (or use CSS var like `bg-muted`), `text-white` (or `text-foreground`), `p-4`. Content: Placeholder text like \"Library Actions\" or similar, as the scan button is removed. This component is retained for structural integrity. 3. Mobile Sidebar `Sheet`: In `+layout.svelte` (or a new `MobileMenuButton.svelte` imported into `PlayerFooter.svelte`), integrate Shadcn `Sheet` component (`bits-ui` based). Triggered by a `Menu` icon `Button` (from `lucide-svelte`, visible only on mobile, likely placed in `PlayerFooter.svelte`). The `Sheet` component should render the `RightSidebar.svelte` content, slide from the right, and close on background click or via a close button within the sheet. Basic unit tests for `RightSidebar.svelte` rendering and `Sheet` trigger/content visibility (mocking Sheet if needed). Focus on Tailwind CSS for layout styling, ensuring minimal custom CSS.",
      "rules_filepaths_to_follow": "`.cursor/rules/svelte.mdc,.cursor/rules/typescript.mdc,.cursor/rules/css.mdc`",
      "filepaths_to_modify": "`frontend/src/routes/(app)/+layout.svelte,frontend/src/lib/components/layout/RightSidebar.svelte,frontend/src/lib/components/layout/PlayerFooter.svelte`",
      "rest": "true"
    },
    {
      "status": "todo",
      "description": "Frontend: Refactor Stores (Player, Track) for New Features, SSE Updates, Dynamic Tab Title, Initial State",
      "details": "Overhaul Svelte stores. 1. `playerStore.ts`: Update `PlayerStoreState` to include `is_shuffle: boolean` (default `false`), `is_repeat: boolean` (default `false`). Add actions: `toggleShuffle()`, `toggleRepeat()`. Ensure existing actions (`setTrack`, `play`, `pause`, etc.) are compatible. 2. `trackStore.ts`: Update `TrackStoreState` to include `playHistory: number[]` (track indices, max 10-20, for shuffle's previous). Actions: `setTracks(tracks: Track[])`. `playTrack(index: number)`: updates `playerStore.currentTrack` and adds to `playHistory` (if not shuffle-next). `nextTrack()`: If `is_shuffle` is true, pick a random track index not equal to current (add to history). If `is_repeat` is true (single track repeat), replay current track. If `is_shuffle` is false and `is_repeat` is false, loop to start if at end of list. `previousTrack()`: If `is_shuffle` is true, pop from `playHistory` and play that track; if history empty, play original previous track (wrapping if at start). If `is_shuffle` is false, play original previous track (wrapping). All navigation actions must update `playerStore.currentTrack` and call `playerStore.play()`. 3. SSE & Dynamic Updates (`+layout.svelte`): In `onMount`, call `apiClient.connectTrackUpdateEvents()`. The callback for this should be: `async () => { const newTracks = await apiClient.fetchTracks(); trackStore.setTracks(newTracks); // Optionally, use svelte-sonner to toast 'Library updated' }`. 4. Initial State & Tab Title (`+layout.svelte`): In `onMount` (or a reactive statement watching `data` prop): Use `data` from `+layout.server.ts` to initialize `trackStore.setTracks(data.tracks)`. Initialize `playerStore` from `data.playerState` (including `is_shuffle`, `is_repeat` if they are added to `PlayerStateDTO` from backend). If `data.playerState.current_track_id` is valid and found in `data.tracks`, set `playerStore.currentTrack` and other player states. Else if `data.tracks` is not empty, set `playerStore.currentTrack` to `data.tracks[0]`, set `trackStore.currentTrackIndex` to 0, and set `playerStore.isPlaying` to `false`. Subscribe to `$playerStore.currentTrack` using a reactive statement (`$:`): if `$playerStore.currentTrack` is set, `document.title = \`\${$playerStore.currentTrack.artist} - \${$playerStore.currentTrack.title}\\\`; else `document.title = \\\"Mus\\\"`. Comprehensive unit tests for store actions (shuffle, repeat, next/prev logic under different modes), SSE-triggered updates (mock `apiClient`), initial state logic, and tab title changes.",
      "rules_filepaths_to_follow": "`.cursor/rules/svelte.mdc,.cursor/rules/typescript.mdc`",
      "filepaths_to_modify": "`frontend/src/lib/stores/playerStore.ts,frontend/src/lib/stores/trackStore.ts,frontend/src/routes/(app)/+layout.svelte,frontend/src/lib/types/index.ts`",
      "rest": "true"
    },
    {
      "status": "todo",
      "description": "Frontend: Implement TrackList and Interactive TrackItem Components with Consistent Text Size & Scrolling",
      "details": "Create Svelte components for track display. 1. `TrackItem.svelte`: Props: `track: Track`, `isSelected: boolean` (derived from `$playerStore.currentTrack?.id === track.id`), `index: number`. Layout: `flex items-center`. Thumbnail: `w-12 h-12 rounded-md overflow-hidden`, display `track.cover_small_url` or a placeholder. On hover of thumbnail, show a dark overlay with a conditional Play/Pause icon (`lucide-svelte`). Main Info: Track Name (bold, `truncate`), Artist (`text-muted-foreground truncate`, consistent text size regardless of play state). If `isSelected` and `$playerStore.isPlaying`, display a thin interactive progress bar (Shadcn `Slider` or custom div) under the track name/artist, linked to `$playerStore.currentTime` and `$playerStore.duration` specifically for this track. Highlight: `bg-muted` (or similar theme color) if `isSelected`. Right side: Formatted duration (`date-fns` or simple formatter). Interaction: Clicking the item calls `trackStore.playTrack(index)`. 2. `TrackList.svelte`: Prop: `tracks: Track[]`. Renders `TrackItem` for each track using an `#each` block with `track.id` as key. Empty state message: \"No tracks available. Library will update automatically.\" Scrolling: Container with `overflow-y-auto` and `max-h-[calc(100vh-Xrem)]` where X is footer height plus any other static vertical elements. When `$trackStore.currentTrackIndex` changes, the corresponding `TrackItem` should be scrolled into view using `element.scrollIntoView({ behavior: 'smooth', block: 'nearest' })`. 3. Integration: Use `TrackList` in `frontend/src/routes/(app)/+page.svelte`, passing `$trackStore.tracks`. Unit tests for `TrackItem` (visual states for selected/playing, interactions, progress bar display/update) and `TrackList` (rendering list, empty state, scroll-to-active functionality by mocking `scrollIntoView`).",
      "rules_filepaths_to_follow": "`.cursor/rules/svelte.mdc,.cursor/rules/typescript.mdc,.cursor/rules/css.mdc`",
      "filepaths_to_modify": "`frontend/src/lib/components/domain/TrackItem.svelte,frontend/src/lib/components/domain/TrackList.svelte,frontend/src/routes/(app)/+page.svelte`",
      "rest": "true"
    },
    {
      "status": "todo",
      "description": "Frontend: Implement Full PlayerFooter, Audio Logic, and Visual Volume Feedback",
      "details": "Develop the player footer with all controls and HTML5 audio integration. 1. `PlayerFooter.svelte`: Use Shadcn `Card` as base, `h-24`, `bg-black` or `bg-neutral-900` (CSS var), `flex justify-between items-center gap-2 px-2`. Left section (track info): Current track thumbnail (`$playerStore.currentTrack.cover_original_url` or placeholder), Name, Artist. Center section (playback controls & progress): Main Progress `Slider` (binds to/updates `$playerStore.currentTime` and sets `audio.currentTime` on change). Formatted current time / total time. Playback buttons (grouped, `lucide-svelte` icons): `SkipBack` (calls `trackStore.previousTrack()`), `Play`/`Pause` (calls `playerStore.togglePlayPause()`, icon changes), `SkipForward` (calls `trackStore.nextTrack()`). Right section (volume & mode controls): Volume `Slider` (binds to/updates `$playerStore.volume`, sets `audio.volume`). Visual Volume Feedback: When volume slider changes, temporarily display a numeric percentage (e.g., using a `svelte-sonner` toast or a small overlay near the slider). Mute `Button` (icon changes based on `$playerStore.isMuted`, calls `playerStore.toggleMute()`). Shuffle `Button` (icon highlights if `$playerStore.isShuffle`, calls `playerStore.toggleShuffle()`). Repeat `Button` (icon highlights if `$playerStore.is_repeat`, calls `playerStore.toggleRepeat()`). Mobile: Add a `Menu` `Button` (e.g., `lucide-svelte` Menu icon) to trigger the `Sheet` for the right sidebar (logic for sheet visibility will be in `+layout.svelte` or a shared store). Sliders should use an accent color like `emerald-400`. 2. Audio Logic (`+layout.svelte`): Manage the global `<audio>` element. Its `src` should be reactively set from `$playerStore.currentTrack` using `getStreamUrl()`. Bind `audio.volume` to `$playerStore.volume` (respecting `isMuted`). Bind `audio.muted` to `$playerStore.isMuted`. Event listeners on `<audio>`: `timeupdate` -> call `playerStore.setCurrentTime(audio.currentTime)`. `loadedmetadata` -> call `playerStore.setDuration(audio.duration)`. `ended` -> if `$playerStore.is_repeat`, call `audio.play()` to restart; else call `trackStore.nextTrack()`. Control `audio.play()`/`audio.pause()` based on `$playerStore.isPlaying` and when `currentTrack` changes. Ensure graceful error handling for `audio.play()`. Unit tests for footer interactions (all buttons, sliders) and audio event handlers (mocking audio element properties/methods and store calls).",
      "rules_filepaths_to_follow": "`.cursor/rules/svelte.mdc,.cursor/rules/typescript.mdc,.cursor/rules/css.mdc`",
      "filepaths_to_modify": "`frontend/src/lib/components/layout/PlayerFooter.svelte,frontend/src/routes/(app)/+layout.svelte`",
      "rest": "true"
    },
    {
      "status": "todo",
      "description": "Frontend: Implement Player State Persistence (Debounced API Calls & Beacon API)",
      "details": "Implement robust player state saving. 1. State Payload DTO Construction: In `playerStore.ts` or `apiClient.ts`, create a helper function to construct the `PlayerState` DTO for the backend. This DTO should include `current_track_id: $playerStore.currentTrack?.id ?? null`, `progress_seconds: $playerStore.currentTime`, `volume_level: $playerStore.volume`, `is_muted: $playerStore.isMuted`, `is_shuffle: $playerStore.isShuffle`, `is_repeat: $playerStore.is_repeat`. 2. Debounced Save Logic (`+layout.svelte` or integrate into `playerStore.ts`): Create a `debouncedSavePlayerState` function. Subscribe to relevant properties of `$playerStore` (currentTrack, currentTime, volume, isMuted, isShuffle, is_repeat). On change, trigger this debounced function (1-2 seconds delay for most changes, 3-5 seconds for `currentTime` during active playback) which then calls `apiClient.savePlayerState()` with the constructed DTO. 3. Beacon API on Unload (`+layout.svelte`): Add `beforeunload` event listener to `window`. Inside the listener, if `navigator.sendBeacon` is available and `$playerStore.currentTrack` exists, construct the player state DTO and use `navigator.sendBeacon(\"/api/v1/player/state\", JSON.stringify(playerStateDto))` (ensure URL is correct, possibly via `apiClient.getBaseUrl()`). Add a `visibilitychange` listener to also try `sendBeacon` if `document.visibilityState === 'hidden'`. 4. Testing: Unit test the DTO construction and debouncing logic. Manual testing across different browsers and scenarios (tab close, browser close, navigation away) is critical for `sendBeacon` reliability. Verify network requests in browser dev tools.",
      "rules_filepaths_to_follow": "`.cursor/rules/svelte.mdc,.cursor/rules/typescript.mdc`",
      "filepaths_to_modify": "`frontend/src/lib/stores/playerStore.ts,frontend/src/routes/(app)/+layout.svelte,frontend/src/lib/services/apiClient.ts`",
      "rest": "true"
    },
    {
      "status": "todo",
      "description": "Frontend: PWA Setup and Page Content Structure",
      "details": "Implement PWA basics and structure the main page content. 1. PWA Setup: Ensure `frontend/static/manifest.json` is correctly configured with `name`, `short_name`, `icons` (referencing actual icon files like `icon-192.svg`, `icon-512.svg` in `frontend/static/images/`), `start_url: \"/\"`, `display: \"standalone\"`, `theme_color` and `background_color` matching the dark theme (e.g., `#020817`). Update/create `frontend/src/service-worker.ts`: use `$service-worker.build` and `$service-worker.files` for caching app shell and static assets. Add `/` route to precache. Implement a network-first or cache-first strategy for appropriate resources. Ensure service worker is registered in `frontend/src/hooks.client.ts`. Update `frontend/src/app.html`: link manifest, set meta theme color, add apple-touch-icon link. 2. Main Page Content (`+page.svelte`): This page primarily hosts the `TrackList` component. Remove any manual scan button logic. Display a message like `\"Found \${$trackStore.tracks.length} tracks\"` or `\"Library is empty. Updates will occur automatically after background scans.\"` based on `$trackStore.tracks.length`. The actual `RightSidebar.svelte` is part of `+layout.svelte` for desktop and in a `Sheet` for mobile. Ensure `+page.svelte` focuses on the main track list area. Write basic rendering tests for messages in `+page.svelte`.",
      "rules_filepaths_to_follow": "`.cursor/rules/svelte.mdc,.cursor/rules/typescript.mdc,.cursor/rules/json.mdc`",
      "filepaths_to_modify": "`frontend/static/manifest.json,frontend/static/images/icon-192.svg,frontend/static/images/icon-512.svg,frontend/src/service-worker.ts,frontend/src/app.html,frontend/src/hooks.client.ts,frontend/src/routes/(app)/+page.svelte`",
      "rest": "true"
    },
    {
      "status": "todo",
      "description": "Frontend: Final Styling, Polish, Comprehensive Testing, and Coverage Analysis",
      "details": "Conduct final review, apply styling refinements, ensure UI/UX polish, and complete comprehensive testing. 1. Styling & Theme Review: Rigorously check all UI elements against the 3-color dark theme specification (background, foreground, muted/accent). Verify `emerald-400` (or chosen accent) on sliders/active states. Ensure consistent spacing, tight layouts, and correct application of Shadcn component styles using Tailwind utilities. Minimize custom CSS in `<style>` tags. 2. Responsiveness & UX Polish: Test thoroughly on desktop, tablet (simulated), and mobile (simulated and real device if possible). Polish all interactions: button feedback (hover, active, focus states), slider usability, track selection highlighting, smooth scrolling in track list. Ensure mobile sidebar `Sheet` is seamless and accessible. 3. Code Quality & Cleanup: Full review of Svelte components, stores, and TypeScript files for clarity, efficiency, maintainability. Remove dead code, unused variables, and non-essential comments. Confirm `xior` usage is strictly encapsulated in `apiClient.ts`. Ensure proper typing throughout. 4. Comprehensive Testing: Finalize all unit tests for stores, components, and services. Manually test all features: playback (play, pause, seek), shuffle (random next, history previous), repeat (single track loop, loop all), volume, mute, track selection from list, player state persistence (load, save during session, unload with Beacon). Test dynamic track list updates via SSE (mock SSE events or test against live backend if feasible). Test PWA installation and basic offline app shell functionality. Test across latest Chrome, Firefox, and Safari (if available). 5. Coverage Report: Run `make front-test-coverage` (or `npm run test:coverage` in `frontend/`). Analyze HTML report generated by `vitest-coverage-v8`, address significant gaps in test coverage if feasible and time permits. 6. Final CI Check: Ensure `make ci` passes cleanly without errors or warnings from linters, formatters, type checkers, or tests. This is the comprehensive QA and sign-off step for the frontend.",
      "rules_filepaths_to_follow": "`.cursor/rules/svelte.mdc,.cursor/rules/typescript.mdc,.cursor/rules/css.mdc,.cursor/rules/makefile_commands.mdc`",
      "filepaths_to_modify": "`frontend/src/`",
      "rest": "true"
    }
  ]
}
